package io.feeba.data.sql

import android.content.ContentValues
import android.content.Context
import io.feeba.data.FeebaResponse
import io.feeba.data.state.AppHistoryState
import io.feeba.data.state.Defaults
import io.feeba.data.state.EventLog
import io.feeba.data.state.PageEventLog
import io.feeba.data.state.StateStorageInterface
import io.feeba.lifecycle.LogLevel
import io.feeba.lifecycle.Logger
import io.least.core.readLocalFile
import io.least.core.writeToLocalFile
import kotlinx.serialization.decodeFromString
import kotlinx.serialization.encodeToString
import kotlinx.serialization.json.Json

class AndroidStateStorage(private val context: Context) : StateStorageInterface {
    private val surveyConfigFileName = "survey_config.json"
    private val localStateFileName = "local_state.json"
    private val jsonInstance = Json { ignoreUnknownKeys = true }

    // DB related variables mostly used for huge pile of data that is generated by client library
    private val dbHelper = FeebaDbHelper(context)
    private val writableDatabase = dbHelper.writableDatabase
    private val readableDatabase = dbHelper.readableDatabase

    override var state: AppHistoryState
        get() {
            return try {
                val localValue = readLocalFile(context.applicationContext, localStateFileName)
                jsonInstance.decodeFromString<AppHistoryState>(localValue)
            } catch (t: Throwable) {
                Logger.log(LogLevel.WARN, "LocalStateHolder:: Failed to read local config. Error: $t")
                Defaults.appHistoryState
            }
        }
        set(value) {
            //        // Write to local file
            try {
                val stringState = jsonInstance.encodeToString(value)
                writeToLocalFile(stringState, context.applicationContext, surveyConfigFileName)
            } catch (t: Throwable) {
//                Logger.log(LogLevel.ERROR, "LocalStateHolder:: Failed to write local config. Error: $t")
            }
        }

    override var feebaResponse: FeebaResponse
        get() {
            return try {
                val localValue = readLocalFile(context.applicationContext, surveyConfigFileName)
                if (localValue.isEmpty()) {
                    Logger.log(LogLevel.WARN, "No locally cached config is found. Is it the first run of the app?")
                    FeebaResponse(listOf())
                }
                jsonInstance.decodeFromString<FeebaResponse>(localValue)
            } catch (t: Throwable) {
                Logger.log(LogLevel.WARN, "LocalStateHolder:: Failed to read local config. Error: $t")
                FeebaResponse(listOf())
            }
        }
        set(value) {
            // Write to local file
            try {
                val stringState = jsonInstance.encodeToString(value)
                writeToLocalFile(stringState, context.applicationContext, surveyConfigFileName)
            } catch (t: Throwable) {
//                Logger.log(LogLevel.ERROR, "LocalStateHolder:: Failed to write local config. Error: $t")
            }
        }

    override fun addPageOpenRecord(pageName: String, value: String) {
        // Create a new map of values, where column names are the keys
        val values = ContentValues().apply {
            put(Contract.PagesEntry.COL_PAGE_NAME, pageName)
            put(Contract.PagesEntry.COL_VALUE, value)
            put(Contract.PagesEntry.COL_CREATED, System.currentTimeMillis())
        }
        try {
            // Insert the new row, returning the primary key value of the new row
            val newRowId = writableDatabase.insert(Contract.PagesEntry.TABLE_NAME, null, values)
        } catch (t: Throwable) {
//            Logger.log(LogLevel.ERROR, "LocalStateHolder:: Failed to add page open record. Error: $t")
        }
    }

    override fun readPageEvenLogs(pageName: String): List<PageEventLog> {
        // Define a projection that specifies which columns from the database
        // you will actually use after this query.
        val projection = arrayOf(
            Contract.PagesEntry.COL_PAGE_NAME,
            Contract.PagesEntry.COL_VALUE,
            Contract.PagesEntry.COL_CREATED
        )
        val selection = "${Contract.PagesEntry.COL_PAGE_NAME} = ?"
        val selectionArgs = arrayOf(pageName)
        val sortOrder = "${Contract.PagesEntry.COL_CREATED} DESC"

        val items = mutableListOf<PageEventLog>()
        try {
            val cursor = readableDatabase.query(
                Contract.PagesEntry.TABLE_NAME,
                projection,
                selection,
                selectionArgs,
                null,
                null,
                sortOrder
            )

            with(cursor) {
                while (moveToNext()) {
                    val pageName = getString(getColumnIndexOrThrow(Contract.PagesEntry.COL_PAGE_NAME))
                    val value = getString(getColumnIndexOrThrow(Contract.PagesEntry.COL_VALUE))
                    val createdAt = getLong(getColumnIndexOrThrow(Contract.PagesEntry.COL_CREATED))
                    items.add(PageEventLog(pageName, value, createdAt))
                }
            }
        } catch (t: Throwable) {
//            Logger.log(LogLevel.ERROR, "LocalStateHolder:: Failed to read page logs. Error: $t")
        }
        return items
    }

    override fun addEventRecord(eventName: String, value: String) {
        // Create a new map of values, where column names are the keys
        val values = ContentValues().apply {
            put(Contract.EventsEntry.COL_EVENT_NAME, eventName)
            put(Contract.EventsEntry.COL_VALUE, value)
            put(Contract.EventsEntry.COL_CREATED, System.currentTimeMillis())
        }
        try {
            // Insert the new row, returning the primary key value of the new row
            val newRowId = writableDatabase.insert(Contract.EventsEntry.TABLE_NAME, null, values)
        } catch (t: Throwable) {
//            Logger.log(LogLevel.ERROR, "LocalStateHolder:: Failed to add event record. Error: $t")
        }
    }

    override fun readEventLogs(eventName: String): List<EventLog> {
        // Define a projection that specifies which columns from the database
        // you will actually use after this query.
        val projection = arrayOf(
            Contract.EventsEntry.COL_EVENT_NAME,
            Contract.EventsEntry.COL_VALUE,
            Contract.EventsEntry.COL_CREATED
        )
        val selection = "${Contract.EventsEntry.COL_EVENT_NAME} = ?"
        val selectionArgs = arrayOf(eventName)
        val sortOrder = "${Contract.EventsEntry.COL_CREATED} DESC"

        val items = mutableListOf<EventLog>()
        try {
            val cursor = readableDatabase.query(
                Contract.EventsEntry.TABLE_NAME,
                projection,
                selection,
                selectionArgs,
                null,
                null,
                sortOrder
            )

            with(cursor) {
                while (moveToNext()) {
                    val eventName = getString(getColumnIndexOrThrow(Contract.EventsEntry.COL_EVENT_NAME))
                    val value = getString(getColumnIndexOrThrow(Contract.EventsEntry.COL_VALUE))
                    val createdAt = getLong(getColumnIndexOrThrow(Contract.EventsEntry.COL_CREATED))
                    items.add(EventLog(eventName, value, createdAt))
                }
            }
        } catch (t: Throwable) {
//            Logger.log(LogLevel.ERROR, "LocalStateHolder:: Failed to read event logs. Error: $t")
        }

        return items
    }

    /**
     * This method is called when the app is opened. When the process is started.
     * This function trims any logs that have been created earlier than 30 days.
     */
    override fun trimData() {
        try {
            // delete all Page Logs that are older than 30 days
            val selectionArgs = arrayOf((System.currentTimeMillis() - 30L * 24 * 60 * 60 * 1000).toString())

            writableDatabase.delete(Contract.PagesEntry.TABLE_NAME, "${Contract.PagesEntry.COL_CREATED} < ?", selectionArgs)
            writableDatabase.delete(Contract.EventsEntry.TABLE_NAME, "${Contract.EventsEntry.COL_CREATED} < ?", selectionArgs)
            // TODO delete all Event Logs that are older than 30 days
        } catch (t: Throwable) {
//            Logger.log(LogLevel.ERROR, "LocalStateHolder:: Failed to trim data. Error: $t")
        }
    }

    override fun eraseEventAndPageLogs() {
        try {
            writableDatabase.delete(Contract.PagesEntry.TABLE_NAME, null, null)
            writableDatabase.delete(Contract.EventsEntry.TABLE_NAME, null, null)
        } catch (t: Throwable) {
//            Logger.log(LogLevel.ERROR, "LocalStateHolder:: Failed to erase event and page logs. Error: $t")
        }
    }
}