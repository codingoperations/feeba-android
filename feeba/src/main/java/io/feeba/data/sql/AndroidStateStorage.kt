package io.feeba.data.sql

import android.content.ContentValues
import android.content.Context
import io.feeba.data.FeebaResponse
import io.feeba.data.state.AppHistoryState
import io.feeba.data.state.Defaults
import io.feeba.data.state.SurveyExecutionLogs
import io.feeba.data.state.StateStorageInterface
import io.feeba.lifecycle.Logger
import io.least.core.readLocalFile
import io.least.core.writeToLocalFile
import kotlinx.serialization.encodeToString
import kotlinx.serialization.json.Json

class AndroidStateStorage(private val context: Context) : StateStorageInterface {
    private val surveyConfigFileName = "survey_config.json"
    private val localStateFileName = "local_state.json"
    private val jsonInstance = Json { ignoreUnknownKeys = true }

    // DB related variables mostly used for huge pile of data that is generated by client library
    private val dbHelper = FeebaDbHelper(context)
    private val writableDatabase = dbHelper.writableDatabase
    private val readableDatabase = dbHelper.readableDatabase

    override var state: AppHistoryState
        get() {
            return try {
                val localValue = readLocalFile(context.applicationContext, localStateFileName)
                jsonInstance.decodeFromString<AppHistoryState>(localValue)
            } catch (t: Throwable) {
                Logger.e("AndroidStateStorage:: Failed to read local config. Error: $t")
                Defaults.appHistoryState
            }
        }
        set(value) {
            //        // Write to local file
            try {
                Logger.e("AndroidStateStorage:: Writing local state...")
                val stringState = jsonInstance.encodeToString(value)
                writeToLocalFile(stringState, context.applicationContext, localStateFileName)
            } catch (t: Throwable) {
                Logger.e("AndroidStateStorage:: Failed to write local config. Error: $t")
            }
        }

    override var feebaResponse: FeebaResponse
        get() {
            return try {
                val localValue = readLocalFile(context.applicationContext, surveyConfigFileName)
                if (localValue.isEmpty()) {
                    Logger.w("AndroidStateStorage::No locally cached config is found. Is it the first run of the app?")
                    FeebaResponse(listOf(), null, listOf())
                }
                jsonInstance.decodeFromString<FeebaResponse>(localValue)
            } catch (t: Throwable) {
                Logger.e("AndroidStateStorage:: Failed to read local config. Error: $t")
                FeebaResponse(listOf(), null, listOf())
            }
        }
        set(value) {
            // Write to local file
            try {
                val stringState = jsonInstance.encodeToString(value)
                writeToLocalFile(stringState, context.applicationContext, surveyConfigFileName)
            } catch (t: Throwable) {
                Logger.e("AndroidStateStorage:: Failed to write local config. Error: $t")
            }
        }

    override fun addPageOpenRecord(pageName: String, value: String, triggeredSurveyId: String) {
        persistExecutionRecord(pageName, triggeredSurveyId, value, ExecutedSurveyTypePage)
    }

    override fun readPageEvenLogs(surveyId: String): List<SurveyExecutionLogs> {
        return readSurveyExecutionLogs(surveyId, ExecutedSurveyTypePage)
    }

    override fun addEventRecord(eventName: String, value: String, triggeredSurveyId: String) {
        persistExecutionRecord(eventName, triggeredSurveyId, value, ExecutedSurveyTypeEvent)
    }

    private fun persistExecutionRecord(
        eventName: String,
        triggeredSurveyId: String,
        value: String,
        type: String
    ) {
        // Create a new map of values, where column names are the keys
        val values = ContentValues().apply {
            put(Contract.SurveyExecutionRecords.COL_TRIGGER_VALUE, eventName)
            put(Contract.SurveyExecutionRecords.COL_TYPE, type)
            put(Contract.SurveyExecutionRecords.COL_TRIGGERED_SURVEY_ID, triggeredSurveyId)
            put(Contract.SurveyExecutionRecords.COL_PAYLOAD, value)
            put(Contract.SurveyExecutionRecords.COL_CREATED, System.currentTimeMillis())
        }
        try {
            // Insert the new row, returning the primary key value of the new row
            writableDatabase.insert(Contract.SurveyExecutionRecords.TABLE_NAME, null, values)
        } catch (t: Throwable) {
            Logger.d("AndroidStateStorage::persistExecutionRecord:: Failed to add a record. Error: $t")
        }
    }

    override  fun readEventLogs(surveyId: String): List<SurveyExecutionLogs> {
        return readSurveyExecutionLogs(surveyId, ExecutedSurveyTypeEvent)
    }

    private fun readSurveyExecutionLogs(
        surveyId: String,
        type: String
    ): MutableList<SurveyExecutionLogs> {
        // Define a projection that specifies which columns from the database
        // you will actually use after this query.
        val projection = arrayOf(
            Contract.SurveyExecutionRecords.COL_TYPE,
            Contract.SurveyExecutionRecords.COL_TRIGGERED_SURVEY_ID,
            Contract.SurveyExecutionRecords.COL_TRIGGER_VALUE,
            Contract.SurveyExecutionRecords.COL_PAYLOAD,
            Contract.SurveyExecutionRecords.COL_CREATED
        )
        val selection =
            "${Contract.SurveyExecutionRecords.COL_TRIGGERED_SURVEY_ID} = ? AND ${Contract.SurveyExecutionRecords.COL_TYPE} = ?"
        val selectionArgs = arrayOf(surveyId, type)
        val sortOrder = "${Contract.SurveyExecutionRecords.COL_CREATED} DESC"

        val items = mutableListOf<SurveyExecutionLogs>()
        try {
            val cursor = readableDatabase.query(
                Contract.SurveyExecutionRecords.TABLE_NAME,
                projection,
                selection,
                selectionArgs,
                null,
                null,
                sortOrder
            )

            with(cursor) {
                while (moveToNext()) {
                    val readSurveyId =
                        getString(getColumnIndexOrThrow(Contract.SurveyExecutionRecords.COL_TRIGGERED_SURVEY_ID))
                    val readType =
                        getString(getColumnIndexOrThrow(Contract.SurveyExecutionRecords.COL_TYPE))
                    val eventName =
                        getString(getColumnIndexOrThrow(Contract.SurveyExecutionRecords.COL_TRIGGER_VALUE))
                    val value =
                        getString(getColumnIndexOrThrow(Contract.SurveyExecutionRecords.COL_PAYLOAD))
                    val createdAt =
                        getLong(getColumnIndexOrThrow(Contract.SurveyExecutionRecords.COL_CREATED))
                    items.add(
                        SurveyExecutionLogs(
                            eventName,
                            value,
                            readSurveyId,
                            readType,
                            createdAt
                        )
                    )
                }
            }
        } catch (t: Throwable) {
            Logger.d("AndroidStateStorage:: Failed to read survey execution logs. Error: $t")
        }
        return items
    }

    /**
     * This method is called when the app is opened. When the process is started.
     * This function trims any logs that have been created earlier than 30 days.
     */
    override fun trimData() {
        try {
            // delete all Page Logs that are older than 30 days
            val selectionArgs =
                arrayOf((System.currentTimeMillis() - 30L * 24 * 60 * 60 * 1000).toString())

            writableDatabase.delete(
                Contract.SurveyExecutionRecords.TABLE_NAME,
                "${Contract.SurveyExecutionRecords.COL_CREATED} < ?",
                selectionArgs
            )
            writableDatabase.delete(
                Contract.SurveyExecutionRecords.TABLE_NAME,
                "${Contract.SurveyExecutionRecords.COL_CREATED} < ?",
                selectionArgs
            )
            // TODO delete all Event Logs that are older than 30 days
        } catch (t: Throwable) {
            Logger.d("AndroidStateStorage:: Failed to trim data. Error: $t")
        }
    }

    override fun eraseEventAndPageLogs() {
        try {
            writableDatabase.delete(Contract.SurveyExecutionRecords.TABLE_NAME, null, null)
            writableDatabase.delete(Contract.SurveyExecutionRecords.TABLE_NAME, null, null)
        } catch (t: Throwable) {
            Logger.d("AndroidStateStorage:: Failed to erase event and page logs. Error: $t")
        }
    }
}